#include "audio_buffer.h"
#include <QObject>
#include <cstddef>
#include <cstdint>
#include <memory>
#include <sample_buffer.h>
#include <stdexcept>
#include <vector>

AudioBuffer::AudioBuffer(size_t aChannelCount, size_t aSampleRate, QObject* aParent)
  : QObject(aParent)
  , mChannelCount(aChannelCount)
  , mSampleRate(aSampleRate)
  , mChannelBuffers(aChannelCount)
{
    if (aChannelCount == 0) {
        throw std::invalid_argument("AudioBuffer: Channel count must be > 0");
    }

    if (aSampleRate == 0) {
        throw std::invalid_argument("AudioBuffer: Sample rate must be > 0");
    }

    for (size_t i = 0; i < aChannelCount; ++i) {
        mChannelBuffers[i] = std::make_unique<SampleBuffer>(aSampleRate);
    }
}

void
AudioBuffer::AddSamples(const std::vector<float>& aSamples)
{
    if (aSamples.size() % mChannelCount != 0) {
        throw std::invalid_argument(
          "AudioBuffer::AddSamples: Sample count must be divisible by channel count");
    }

    const size_t kSamplesPerChannel = aSamples.size() / mChannelCount;
    std::vector<float> channelSamples(kSamplesPerChannel); // Deinterleave buffer

    for (size_t channelID = 0; channelID < mChannelCount; channelID++) {
        // De-interleave one channel
        for (size_t i = 0; i < kSamplesPerChannel; i++) {
            channelSamples[i] = aSamples[(i * mChannelCount) + channelID];
        }

        // Then feed it to the SampleBuffer
        mChannelBuffers[channelID]->AddSamples(channelSamples);
    }

    // NOLINTNEXTLINE(misc-include-cleaner) -- emit is generated by moc
    emit dataAvailable(kSamplesPerChannel);
}

std::vector<float>
AudioBuffer::GetSamples(const size_t aChannelIndex,
                        const int64_t aStartSample,
                        const size_t aSampleCount) const
{
    if (aChannelIndex >= mChannelCount) {
        throw std::out_of_range("AudioBuffer::GetSamples: Channel index out of range");
    }

    return mChannelBuffers[aChannelIndex]->GetSamples(aStartSample, aSampleCount);
}

const SampleBuffer&
AudioBuffer::GetChannelBuffer(size_t aChannelIndex) const
{
    if (aChannelIndex >= mChannelCount) {
        throw std::out_of_range("AudioBuffer::GetChannelBuffer: Channel index out of range");
    }

    return *mChannelBuffers[aChannelIndex];
}
