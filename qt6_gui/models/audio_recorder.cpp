#include "audio_recorder.h"
#include "audio_buffer.h"
#include "include/global_constants.h"
#include <QAudio>
#include <QAudioDevice>
#include <QAudioFormat>
#include <QAudioSource>
#include <QByteArray>
#include <QIODevice>
#include <QObject>
#include <QtTypes>
#include <cstddef>
#include <format>
#include <memory>
#include <stdexcept>
#include <vector>

AudioRecorder::AudioRecorder(AudioBuffer& aAudioBuffer, QObject* aParent)
  : QObject(aParent)
  , mAudioBuffer(aAudioBuffer)
{
}

AudioRecorder::~AudioRecorder()
{
    Stop();
}

bool
AudioRecorder::Start(const QAudioDevice& aQAudioDevice,
                     int aChannelCount,
                     int aSampleRate,
                     QIODevice* aMockQIODevice)
{
    if (aChannelCount <= 0 || aChannelCount > gkMaxChannels) {
        throw std::invalid_argument(
          std::format("{}: Invalid channel count {}", __PRETTY_FUNCTION__, aChannelCount));
    }

    if (aSampleRate <= 0) {
        throw std::invalid_argument(
          std::format("{}: Invalid sample rate {}", __PRETTY_FUNCTION__, aSampleRate));
    }

    QAudioFormat format;
    format.setSampleRate(aSampleRate);
    format.setChannelCount(aChannelCount);
    format.setSampleFormat(QAudioFormat::Float);

    mAudioBuffer.Reset(aChannelCount, aSampleRate);

    mAudioSource = std::make_unique<QAudioSource>(aQAudioDevice, format);

    if (!mAudioSource) {
        // NOLINTNEXTLINE(misc-include-cleaner) -- emit is generated by moc
        emit ErrorOccurred("Failed to create QAudioSource");
        return false;
    }

    // How many samples the source should buffer before triggering readyRead.
    // 44100Hz sample rate * 2 channels * 4 bytes per sample / 60Hz display rate
    // gives us 5880 bytes.  We'll choose something smaller than that to keep
    // the updates coming quickly even if the sample rate is lower.  In
    // practice, we seem to get ~3-4K, perhaps due to scheduling limitations.
    // TODO: investigate how to choose an optimal value here, taking into
    // account sample rate, channels, display refresh rate, jitter, etc.
    constexpr qsizetype kSourceBufferSize = 2048;
    mAudioSource->setBufferSize(kSourceBufferSize);

    // In test, this value will be discarded and replaced with the mock.
    // Unfortunately we can't override start() to inject the mock.
    mAudioIODevice = mAudioSource->start();

    if (!mAudioIODevice) {
        // NOLINTNEXTLINE(misc-include-cleaner) -- emit is generated by moc
        emit ErrorOccurred("Failed to start audio input");
        return false;
    }

    // In test, discard the real QIODevice and replace it with the mock.
    if (aMockQIODevice) {
        mAudioIODevice = aMockQIODevice;
    }

    connect(mAudioIODevice, &QIODevice::readyRead, this, &AudioRecorder::ReadAudioData);
    // NOLINTNEXTLINE(misc-include-cleaner) -- emit is generated by moc
    emit RecordingStateChanged(true);
    return true;
}

void
AudioRecorder::Stop()
{
    if (mAudioSource && mAudioSource->state() != QAudio::StoppedState) {
        mAudioSource->stop();
        mAudioSource.reset();
        // NOLINTNEXTLINE(misc-include-cleaner) -- emit is generated by moc
        emit RecordingStateChanged(false);
    }
    mAudioIODevice = nullptr;
}

void
AudioRecorder::ReadAudioData()
{
    if (!mAudioIODevice) {
        // This should be set during Start(), and this callback shouldn't
        // happen unless we're started and recording.
        throw std::runtime_error("AudioRecorder::ReadAudioData called when not recording");
    }

    // Read it into a QByteArray, then convert to float vector.
    const QByteArray audioData = mAudioIODevice->readAll();
    if (audioData.size() % sizeof(float) != 0) {
        throw std::runtime_error(
          "AudioRecorder::ReadAudioData: Read bytes not divisible by sample size");
    }

    const auto sampleCount = static_cast<size_t>(audioData.size() / sizeof(float));

    // Type punning is intentional: we need to interpret the byte stream as floats.
    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
    const auto* sampleData = reinterpret_cast<const float*>(audioData.constData());
    // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic)
    const std::vector<float> samples(sampleData, sampleData + sampleCount);

    // Then send it to the AudioBuffer.
    mAudioBuffer.AddSamples(samples);
}

bool
AudioRecorder::IsRecording() const
{
    if (!mAudioSource) {
        return false;
    }

    // TODO: Revisit whether "IdleState" should count as recording.  It's the
    // best we can do with the current mocks.  We don't otherwise use this
    // state, so it should be fine for now.
    switch (mAudioSource->state()) {
        case QAudio::ActiveState:
        case QAudio::IdleState:
            return true;
        case QAudio::StoppedState:
        case QAudio::SuspendedState:
            return false;
        default:
            throw std::runtime_error(
              std::format("AudioRecorder::IsRecording: Unknown QAudio state {}",
                          static_cast<int>(mAudioSource->state())));
    }
}
