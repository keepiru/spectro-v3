#include "audio_recorder.h"
#include "audio_buffer.h"
#include <QAudio>
#include <QAudioDevice>
#include <QAudioFormat>
#include <QAudioSource>
#include <QByteArray>
#include <QIODevice>
#include <QObject>
#include <QtTypes>
#include <cstddef>
#include <memory>
#include <stdexcept>
#include <vector>

AudioRecorder::AudioRecorder(QObject* aParent)
  : QObject(aParent)
{
}

AudioRecorder::~AudioRecorder()
{
    Stop();
}

bool
AudioRecorder::Start(AudioBuffer* aAudioBuffer,
                     const QAudioDevice& aQAudioDevice,
                     QIODevice* aMockQIODevice)
{
    if (!aAudioBuffer) {
        throw std::invalid_argument("AudioBuffer pointer cannot be null");
    }

    mAudioBuffer = aAudioBuffer;
    const auto format = CreateFormatFromBuffer(aAudioBuffer);

    mAudioSource = std::make_unique<QAudioSource>(aQAudioDevice, format);

    if (!mAudioSource) {
        // NOLINTNEXTLINE(misc-include-cleaner) -- emit is generated by moc
        emit errorOccurred("Failed to create QAudioSource");
        return false;
    }

    // How many samples the source should buffer before triggering readyRead.
    // 44100Hz sample rate * 2 channels * 4 bytes per sample / 60Hz display rate
    // gives us 5880 bytes.  We'll choose something smaller than that to keep
    // the updates coming quickly even if the sample rate is lower.  In
    // practice, we seem to get ~3-4K, perhaps due to scheduling limitations.
    // TODO: investigate how to choose an optimal value here, taking into
    // account sample rate, channels, display refresh rate, jitter, etc.
    constexpr qsizetype kSourceBufferSize = 2048;
    mAudioSource->setBufferSize(kSourceBufferSize);

    // In test, this value will be discarded and replaced with the mock.
    // Unfortunately we can't override start() to inject the mock.
    mAudioIODevice = mAudioSource->start();

    if (!mAudioIODevice) {
        // NOLINTNEXTLINE(misc-include-cleaner) -- emit is generated by moc
        emit errorOccurred("Failed to start audio input");
        return false;
    }

    // In test, discard the real QIODevice and replace it with the mock.
    if (aMockQIODevice) {
        mAudioIODevice = aMockQIODevice;
    }

    connect(mAudioIODevice, &QIODevice::readyRead, this, &AudioRecorder::ReadAudioData);
    // NOLINTNEXTLINE(misc-include-cleaner) -- emit is generated by moc
    emit recordingStateChanged(true);
    return true;
}

void
AudioRecorder::Stop()
{
    if (mAudioSource && mAudioSource->state() != QAudio::StoppedState) {
        mAudioSource->stop();
        mAudioSource.reset();
        // NOLINTNEXTLINE(misc-include-cleaner) -- emit is generated by moc
        emit recordingStateChanged(false);
    }
    mAudioIODevice = nullptr;
}

QAudioFormat
AudioRecorder::CreateFormatFromBuffer(const AudioBuffer* aBuffer)
{
    QAudioFormat format;
    format.setSampleRate(static_cast<int>(aBuffer->GetSampleRate()));
    format.setChannelCount(static_cast<int>(aBuffer->GetChannelCount()));
    format.setSampleFormat(QAudioFormat::Float);
    return format;
}

void
AudioRecorder::ReadAudioData()
{
    if (!mAudioBuffer || !mAudioIODevice) {
        // These should be set during Start(), and this callback shouldn't
        // happen unless we're started and recording.
        throw std::runtime_error("AudioRecorder::ReadAudioData called when not recording");
    }

    // Read it into a QByteArray, then convert to float vector.
    const QByteArray audioData = mAudioIODevice->readAll();
    if (audioData.size() % sizeof(float) != 0) {
        throw std::runtime_error(
          "AudioRecorder::ReadAudioData: Read bytes not divisible by sample size");
    }

    const auto sampleCount = static_cast<size_t>(audioData.size() / sizeof(float));

    // Type punning is intentional: we need to interpret the byte stream as floats.
    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
    const auto* sampleData = reinterpret_cast<const float*>(audioData.constData());
    // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic)
    const std::vector<float> samples(sampleData, sampleData + sampleCount);

    // Then send it to the AudioBuffer.
    mAudioBuffer->AddSamples(samples);
}
