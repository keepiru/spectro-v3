#include "models/settings.h"
#include "include/global_constants.h"
#include <QObject>
#include <algorithm>
#include <array>
#include <cstddef>
#include <cstdint>
#include <fft_window.h>
#include <format>
#include <stdexcept>

Settings::Settings(QObject* aParent)
  : QObject(aParent)
  , mColorMapLUTs()
{
    // Initialize default color maps
    for (size_t ch = 0; ch < gkMaxChannels; ch++) {
        SetColorMap(ch, KDefaultColorMaps.at(ch));
    }
}

void
Settings::SetFFTSettings(const size_t aTransformSize, const FFTWindow::Type aWindowType)
{
    if (aTransformSize == 0 || (aTransformSize & (aTransformSize - 1)) != 0) {
        throw std::invalid_argument("FFT size must be a power of two and greater than zero");
    }

    if (mFFTSize != aTransformSize || mWindowType != aWindowType) {
        mFFTSize = aTransformSize;
        mWindowType = aWindowType;
        emit FFTSettingsChanged(); // NOLINT(misc-include-cleaner) // emit is generated by moc
    }
}

void
Settings::SetWindowScale(const size_t aScale)
{
    const std::array<size_t, 5> validScales{ 1, 2, 4, 8, 16 };
    if (std::ranges::find(validScales, aScale) == validScales.end()) {
        throw std::invalid_argument("Window scale must be one of: 1, 2, 4, 8, or 16");
    }

    mWindowScale = aScale;
    emit WindowScaleChanged(); // NOLINT(misc-include-cleaner) // emit is generated by moc
}

void
Settings::SetColorMap(size_t aChannel, ColorMapType aType)
{
    // Helper to set a gradient color map
    auto setGradientColorMap = [this, aChannel](bool enableRed, bool enableGreen, bool enableBlue) {
        for (size_t i = 0; i < KColorMapLUTSize; i++) {
            const auto intensity = static_cast<uint8_t>(i);
            mColorMapLUTs.at(aChannel).at(i) =
              ColorMapEntry{ .r = enableRed ? intensity : uint8_t{ 0 },
                             .g = enableGreen ? intensity : uint8_t{ 0 },
                             .b = enableBlue ? intensity : uint8_t{ 0 } };
        }
    };

    switch (aType) {
        case ColorMapType::White:
            setGradientColorMap(true, true, true);
            break;
        case ColorMapType::Red:
            setGradientColorMap(true, false, false);
            break;
        case ColorMapType::Green:
            setGradientColorMap(false, true, false);
            break;
        case ColorMapType::Blue:
            setGradientColorMap(false, false, true);
            break;
        case ColorMapType::Cyan:
            setGradientColorMap(false, true, true);
            break;
        case ColorMapType::Magenta:
            setGradientColorMap(true, false, true);
            break;
        case ColorMapType::Yellow:
            setGradientColorMap(true, true, false);
            break;
        default:
            throw std::invalid_argument("Settings::SetColorMap: Unsupported color map type");
    }

    mSelectedColorMaps.at(aChannel) = aType;
}

void
Settings::SetApertureMinDecibels(const float aMinDecibels)
{
    if (aMinDecibels >= mApertureMaxDecibels) {
        throw std::invalid_argument(
          std::format("Aperture min decibels {} must be less than max decibels {}",
                      aMinDecibels,
                      mApertureMaxDecibels));
    }
    mApertureMinDecibels = aMinDecibels;
    emit ApertureSettingsChanged(); // NOLINT(misc-include-cleaner) // emit is generated by moc
}

void
Settings::SetApertureMaxDecibels(const float aMaxDecibels)
{
    if (aMaxDecibels <= mApertureMinDecibels) {
        throw std::invalid_argument(
          std::format("Aperture max decibels {} must be greater than min decibels {}",
                      aMaxDecibels,
                      mApertureMinDecibels));
    }
    mApertureMaxDecibels = aMaxDecibels;
    emit ApertureSettingsChanged(); // NOLINT(misc-include-cleaner) // emit is generated by moc
}
